
This quick example shows how you can create custom replay components to record custom Unity components or generic data.
Replay components are simple scripts that provide a means of serializing and deserializing data and may look similar to some networking solutions that support serializing custom data.
It is also the job of the replay component if applicable to implement any interpolation that may be required to achieve smooth playback while recording with low record fps rates.

For the example we will just serialize some simple fields, but really the data could come from anywhere and be in almost any format so long as it can be written into a `ReplayState`.
That includes arrays and other complex data, but you should be aware that a replay component should write as little data as possible to the provided `ReplayState` in order to remain performant and keep file storage sizes to a minimum.

As a useful guide you will see the current amount of bytes generated by your custom replay component in the inspector window, and your goal is to minimize that value wile recording all necessary data.

![image](https://github.com/TrivialInteractive/Ultimate-Replay-3.0-Samples/blob/be6f35dec86e96b999b9334d9d0ecc0cb2daaa0e/Images/CodeExamples/ReplayComponentInspector.png)

```cs
using UnityEngine;
using UltimateReplay;
using UltimateReplay.Storage;

// IMPORTANT - Custom replay components must derive from `ReplayRecordableBehaviour`
public class Example : ReplayRecordableBehaviour
{
	// Used for interpolation smoothing only 
	private float myFloatDataPrevious = 0f;
	private float myFloatDataNext = 0f;

	// The public data that we will record and replay for this example. 
	// The data could also come from an external component or really from any source.
	public int myIntData = 0;	
	public string myStringData = "Hello World";
	public float myFloatData = 0f;

	// This method is called when the component should serialize any custom data, usually called around 1-48 times per second depending upon record rate
	public override void OnReplaySerialize(ReplayState state)
	{
		// Simply write our data taking care over the write order (We will need to read back in the same order)
		state.Write(myIntData);		
		state.Write(myStringData);
		state.Write(myFloatData);
	}

	// This method is called when the component should deserialize any custom data, usually called 1 or more times per frame
	public override void OnReplayDeserialize(ReplayState state)
	{
		myIntData = state.ReadInt32();
		myStringData = state.ReadString();
		
		// To support interpolation we can use a couple of member variables (NOTE: We do not actually assign `myFloatData` here)
		myFloatDataPrevious = myFloatDataNext;
		myFloatDataNext = state.ReadSingle();
	}

	// Recommended to reset the member values when entering playback mode to eliminate any posisble left over data issues
	protected override void OnReplayReset()
	{
		myFloatDataPrevious = myFloatDataNext;
	}

	// Interpolation should be performed inside replay update as it provides the necessary `t` delta value
	// NOTE: If interpolation is not needed then we can simply assign the `myFloatData` value from the state in `OnReplayDeserialize`
	protected override void OnReplayUpdate(float t)
	{
		// Perform the interpolation/smoothing of values where `t` represents the delta between replay snapshots
		myFloatData = Mathf.Lerp(myFloatDataPrevious, myFloatDataNext, t);
	}
}
```
